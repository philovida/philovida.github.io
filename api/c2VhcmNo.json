[{"title":"windows安装python虚拟环境","date":"2019-08-05T16:00:00.000Z","updated":"2019-08-06T01:42:18.000Z","content":"使用virtualenv安装虚拟环境\n\n使用虚拟环境安装Flask，可以避免包的混乱和版本的冲突，虚拟环境是Python解释器的副本，在虚拟环境中你可以安装扩展包，为每个程序单独创建的虚拟环境，可以保证程序只能访问虚拟环境中的包。而不会影响系统中安装的全局Python解释器，从而保证全局解释器的整洁。\n安装安装virtualenv\n1pip3 install virtualenv\n\n安装virtualenv的win驱动\n1pip3 install virtualenvwrapper-win\n\n创建虚拟环境首先创建一个虚拟环境的目录，以flask_py为例。进入目录中执行命令\n1mkvirtualenv Flask_py #将该目录设置成虚拟环境\n\n执行后，自动启用了该虚拟环境。到这里安装便结束了。\n命令进入虚拟环境workon Flask.py退出虚拟环境deactivate Flask.py\n","plink":"http://localhost:4000/post/windows安装python虚拟环境/"},{"title":"Windows下安装部署Redis服务","date":"2019-08-04T16:00:00.000Z","updated":"2019-08-06T12:13:45.062Z","content":"windows系统下redis服务的安装\n\n\n引用自：https://www.cnblogs.com/weiqinl/p/6490372.htmlRedis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。由于用于开发电脑是windows，记录下windows环境下redis服务的安装\nredis安装下载windows版本：https://github.com/MSOpenTech/redis/releases安装版：在打开的github页面中，找到Latest release版本下面的Redis-x64-3.0.504.msi，下它！源码版：在打开的github页面中，找到Latest release版本下面的Redis-x64-3.0.504.zip。下它！由于安装版会直接写入windows服务，比较方便。下面讨论的是源码版的安装。\n解压安装将下载好的安装包解压缩到任意一个目录。我的安装目录是D:\\app\\Redis-x64-3.0.504\n验证使用cmd进入redis安装目录，以我本地环境为例：\n1234# 切换到D盘C:\\Users\\user&gt;D:# 进入redis安装目录D:\\&gt;cd app\\Redis-x64-3.0.504\n\n启动redis-server.exe、\n1D:\\app\\Redis-x64-3.0.504&gt;redis-server.exe\n\n出现下面的效果，说明服务启动成功\n\n再启动一个cmd窗口，同样进入redis安装目录，启动redis-cli.exe，连接我们刚刚启动好的server\n1D:\\app\\Redis-x64-3.0.504&gt;redis-cli.exe\n\n出现下面的效果，说明客户端启动成功\n\n部署上面的方法，只要关闭了redis-server的命令行窗口，服务就会停掉。所以我们需要把redis设置为一个windows服务。在redis安装目录中，使用下面命令进行安装。\n12# 安装命令redis-server.exe --service-install redis.windows.conf\n\n安装成功如下图所示：\n\n\n常用redis服务命令\n卸载服务：redis-server --service-uninstall\n开启服务：redis-server --service-start\n停止服务：redis-server --service-stop\n重命名服务：redis-server --service-name name\n\n例子如下：启动两个不同的Redis实例作为服务\n12345678# 安装服务1redis-server --server-install --service-name redisService1 --port 10001# 启动服务1redis-server --service-start --service-name redisService1# 安装服务2redis-server --server-install --service-name redisService1 --port 10002# 启动服务2redis-server --service-start --service-name redisService2\n\n部署验证启动服务123# 同样要在redis的安装目录执行。# 或者将Redis目录加入到系统变量path中，可以在任意地方用命令行执行。redis-server --service-start\n\n测试打开redis-cli.exe，进行读写数据测试（由于我的环境已经把redis目录加入了path，所以直接执行redis-cli.exe）\n12345$ redis-cli.exe127.0.0.1:6379&gt; set 2019 hello# 返回值：OK127.0.0.1:6379&gt; get 2019# 返回值：\"hello\"\n\n到这里验证成功，说明redis服务已经成功安装了。\n工具推荐推荐一款Redis可视化链接工具，叫Redis Destop Manager。\n\n官网地址：https://redisdesktop.com/download虽说是开源的，但在官网上面没有找到免费下载的地方，不过其他网站搜搜还是能搜索到的。\n","plink":"http://localhost:4000/post/Windows下安装部署Redis服务/"},{"title":"Http协议","date":"2019-08-02T16:00:00.000Z","updated":"2019-08-03T08:32:26.517Z","content":"http协议学习\n\n\nhttp协议http协议通俗讲解通过网络调试助手接受http请求1) 将网络调试助手设置成TCP服务器，ip为127.0.0.1，端口为80802) 在浏览器网址处输入：127.0.0.1:8080，可以看到网络调试助手中收到了请求。\n12345678910# 请求格式【Receive from 127.0.0.1 : 51437】：GET / HTTP/1.1Host: 127.0.0.1:8080Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: pageNo=1; pageSize=10\n\n12345678910111213141516171819202122# header（应答格式）HTTP/1.1 200 OK                   # 必须有Bdpagetype: 1Bdqid: 0xfb356cc60008504eCache-Control: privateConnection: Keep-AliveContent-Encoding: gzipContent-Type: text/htmlCxy_all: baidu+aa0567522ab3525001c86f4d0d3cb993Date: Thu, 11 Apr 2019 08:33:38 GMTExpires: Thu, 11 Apr 2019 08:32:59 GMTServer: BWS/1.1Set-Cookie: delPer=0; path=/; domain=.baidu.com  Set-Cookie: BDSVRTM=0; path=/Set-Cookie: BD_HOME=0; path=/Set-Cookie: H_PS_PSSID=1430_28793_21106_28769_28724_28557_28838_28585_28640_26350_28603_28627_28605; path=/; domain=.baidu.comStrict-Transport-Security: max-age=172800Vary: Accept-EncodingX-Ua-Compatible: IE=Edge,chrome=1Transfer-Encoding: chunked# body（应答体） 第一个空行下面的都是body\n\n\nSet-Cookie: H_PS_PSSID=1430_28793_21106_28769_28724_28557_28838_28585_28640_26350_28603_28627_28605; path=/; domain=.baidu.com意思是浏览器创建一个H_PS_PSSID变量来存储后面的值，如果访问百度网站就会把这串cookie发过去，用来标识”你是谁”。服务器可以根据你的身份及历史行为，通过阿里妈妈发送营销广告。\n\n\n1688.com是阿里批发的网站，有些淘宝店收到订单会联系1688发货，从而赚取差价。\n\npython编写简单tcp服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445import socketdef server_deal(client_socket):    # 接受对方发送的请求    recv_data = client_socket.recv(1024)    print('接收到的数据为:', recv_data.decode('utf-8'))    if recv_data:        # 设置返回内容，只要接受到请求，就返回        send_data = 'HTTP/1.1 200 OK\\r\\n\\r\\n&lt;h1&gt;hahahaha&lt;/h1&gt;'        client_socket.send(send_data.encode('utf-8'))        # 关闭socket    client_socket.close()def main():    # 创建socket套接字    tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置本地的IP、端口    addr = ('', 1207)    # 绑定端口    tcp_socket.bind(addr)    # 开启listen监听    tcp_socket.listen(128)    while True:        # 为客户端持续提供服务        client_socket, client_addr = tcp_socket.accept()        # 处理请求        server_deal(client_socket)    tcp_socket.closeif __name__ == \"__main__\":    main()\n\n\n该程序，如果强制停止的话，立即重新启动会报错：端口被占用。因为先调用close的要等待一段时间才能关闭，详情见tcp四次挥手\n\n12# 可以通过该代码使得服务器调用close后立即释放资源server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\ntcp三次握手、四次挥手单进程-单线程-多任务tcp服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103from socket import *import reimport timeHOST = ''PORT = 7890ADDR = (HOST, PORT)BUFSIZ = 1024SOCK_LIST = list() # 用来存储请求的客户端socketdef server_socket(tcpCliSock, recv_data):    # 接受客户端请求    # recv_data = tcpCliSock.recv(BUFSIZ)    # 判断客户端请求的资源,将文件名找出来    req_dgram = recv_data.decode('utf-8').splitlines()    ret = re.match('[^/]*(/[^ ]*)', req_dgram[0])    if ret:        file_name = ret.group(1)        if file_name == '/':            file_name = '/index.html'    # 根据请求资源，打开对应文件并读取内容    try:        f = open('tcp_server/html'+ file_name, 'rb')    except Exception as ret:        response_body = '文件没有找到'        response_header = 'HTTP/1.1 404 NOT FOUND\\r\\n'        response_header += 'Content-Type:text/html; charset=UTF-8\\r\\n'        response_header += '\\r\\n'        response = response_header.encode('utf-8') + response_body.encode('utf-8')    else:        html_content = f.read()        f.close()        # 组装应答报文        response_body = html_content        response_header = 'HTTP/1.1 200 OK\\r\\n'        response_header += 'Content-Length:%d\\r\\n'% len(response_body)        response_header += '\\r\\n'        response = response_header.encode('utf-8') + response_body    # 发送数据    tcpCliSock.send(response)            # 关闭套接字    # tcpCliSock.close()def main():    # 创建套接字    tcpSock = socket(AF_INET, SOCK_STREAM)        # 绑定端口    tcpSock.bind(ADDR)    # 启用监听    tcpSock.listen(128)    # 将服务器套接字设置成非堵塞    tcpSock.setblocking(False)    while True:        time.sleep(1)        # 设置被动套接字，为客户端提供服务.        # 非堵塞accept如果没有客户端请求，则会报异常，因此用try来处理异常情况。        try:            tcpCliSock, addr = tcpSock.accept()        except Exception as ret:            print('还没有客户端来连接')        else:            tcpCliSock.setblocking(False)            print('&gt;&gt;&gt;&gt;&gt;来了一个客户端&gt;&gt;&gt;&gt;&gt;')            SOCK_LIST.append(tcpCliSock)        # recv非堵塞时，如果没有收到数据会报异常。同样使用try来处理异常情况        for client in SOCK_LIST:             try:                recv_data = client.recv(BUFSIZ)            except Exception as ret:                print('*****客户端怎么还不发送数据呢*******')            else:                if recv_data:                    server_socket(tcpCliSock, recv_data)                # 如果客户端发送的数据为空，意味着客户端断开连接                # 先将客户端socket关闭                # 再将list中的客户端socket删除                else:                    client.close()                    SOCK_LIST.remove(client)        tcpSock.close()if __name__ == \"__main__\":    main()\n\n\n问题1：在打开html文件的时候，一直提示No such file or directory。检查发现html文件相对路径与代码相比没有问题，但是由于是在vscode终端运行，终端提示符的位置是在代码的上层目录，所以相对路径就不能以代码为准，而要以终端运行的位置为准。\n\n","plink":"http://localhost:4000/post/Http协议/"},{"title":"about","date":"2019-08-03T01:04:49.000Z","updated":"2019-08-03T01:06:53.619Z","content":"","plink":"http://localhost:4000/about/"}]