[{"title":"Http协议","date":"2019-08-02T16:00:00.000Z","updated":"2019-08-03T08:32:26.517Z","content":"http协议学习\n\n\nhttp协议http协议通俗讲解通过网络调试助手接受http请求1) 将网络调试助手设置成TCP服务器，ip为127.0.0.1，端口为80802) 在浏览器网址处输入：127.0.0.1:8080，可以看到网络调试助手中收到了请求。\n12345678910# 请求格式【Receive from 127.0.0.1 : 51437】：GET / HTTP/1.1Host: 127.0.0.1:8080Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: pageNo=1; pageSize=10\n\n12345678910111213141516171819202122# header（应答格式）HTTP/1.1 200 OK                   # 必须有Bdpagetype: 1Bdqid: 0xfb356cc60008504eCache-Control: privateConnection: Keep-AliveContent-Encoding: gzipContent-Type: text/htmlCxy_all: baidu+aa0567522ab3525001c86f4d0d3cb993Date: Thu, 11 Apr 2019 08:33:38 GMTExpires: Thu, 11 Apr 2019 08:32:59 GMTServer: BWS/1.1Set-Cookie: delPer=0; path=/; domain=.baidu.com  Set-Cookie: BDSVRTM=0; path=/Set-Cookie: BD_HOME=0; path=/Set-Cookie: H_PS_PSSID=1430_28793_21106_28769_28724_28557_28838_28585_28640_26350_28603_28627_28605; path=/; domain=.baidu.comStrict-Transport-Security: max-age=172800Vary: Accept-EncodingX-Ua-Compatible: IE=Edge,chrome=1Transfer-Encoding: chunked# body（应答体） 第一个空行下面的都是body\n\n\nSet-Cookie: H_PS_PSSID=1430_28793_21106_28769_28724_28557_28838_28585_28640_26350_28603_28627_28605; path=/; domain=.baidu.com意思是浏览器创建一个H_PS_PSSID变量来存储后面的值，如果访问百度网站就会把这串cookie发过去，用来标识”你是谁”。服务器可以根据你的身份及历史行为，通过阿里妈妈发送营销广告。\n\n\n1688.com是阿里批发的网站，有些淘宝店收到订单会联系1688发货，从而赚取差价。\n\npython编写简单tcp服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445import socketdef server_deal(client_socket):    # 接受对方发送的请求    recv_data = client_socket.recv(1024)    print('接收到的数据为:', recv_data.decode('utf-8'))    if recv_data:        # 设置返回内容，只要接受到请求，就返回        send_data = 'HTTP/1.1 200 OK\\r\\n\\r\\n&lt;h1&gt;hahahaha&lt;/h1&gt;'        client_socket.send(send_data.encode('utf-8'))        # 关闭socket    client_socket.close()def main():    # 创建socket套接字    tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置本地的IP、端口    addr = ('', 1207)    # 绑定端口    tcp_socket.bind(addr)    # 开启listen监听    tcp_socket.listen(128)    while True:        # 为客户端持续提供服务        client_socket, client_addr = tcp_socket.accept()        # 处理请求        server_deal(client_socket)    tcp_socket.closeif __name__ == \"__main__\":    main()\n\n\n该程序，如果强制停止的话，立即重新启动会报错：端口被占用。因为先调用close的要等待一段时间才能关闭，详情见tcp四次挥手\n\n12# 可以通过该代码使得服务器调用close后立即释放资源server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\ntcp三次握手、四次挥手单进程-单线程-多任务tcp服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103from socket import *import reimport timeHOST = ''PORT = 7890ADDR = (HOST, PORT)BUFSIZ = 1024SOCK_LIST = list() # 用来存储请求的客户端socketdef server_socket(tcpCliSock, recv_data):    # 接受客户端请求    # recv_data = tcpCliSock.recv(BUFSIZ)    # 判断客户端请求的资源,将文件名找出来    req_dgram = recv_data.decode('utf-8').splitlines()    ret = re.match('[^/]*(/[^ ]*)', req_dgram[0])    if ret:        file_name = ret.group(1)        if file_name == '/':            file_name = '/index.html'    # 根据请求资源，打开对应文件并读取内容    try:        f = open('tcp_server/html'+ file_name, 'rb')    except Exception as ret:        response_body = '文件没有找到'        response_header = 'HTTP/1.1 404 NOT FOUND\\r\\n'        response_header += 'Content-Type:text/html; charset=UTF-8\\r\\n'        response_header += '\\r\\n'        response = response_header.encode('utf-8') + response_body.encode('utf-8')    else:        html_content = f.read()        f.close()        # 组装应答报文        response_body = html_content        response_header = 'HTTP/1.1 200 OK\\r\\n'        response_header += 'Content-Length:%d\\r\\n'% len(response_body)        response_header += '\\r\\n'        response = response_header.encode('utf-8') + response_body    # 发送数据    tcpCliSock.send(response)            # 关闭套接字    # tcpCliSock.close()def main():    # 创建套接字    tcpSock = socket(AF_INET, SOCK_STREAM)        # 绑定端口    tcpSock.bind(ADDR)    # 启用监听    tcpSock.listen(128)    # 将服务器套接字设置成非堵塞    tcpSock.setblocking(False)    while True:        time.sleep(1)        # 设置被动套接字，为客户端提供服务.        # 非堵塞accept如果没有客户端请求，则会报异常，因此用try来处理异常情况。        try:            tcpCliSock, addr = tcpSock.accept()        except Exception as ret:            print('还没有客户端来连接')        else:            tcpCliSock.setblocking(False)            print('&gt;&gt;&gt;&gt;&gt;来了一个客户端&gt;&gt;&gt;&gt;&gt;')            SOCK_LIST.append(tcpCliSock)        # recv非堵塞时，如果没有收到数据会报异常。同样使用try来处理异常情况        for client in SOCK_LIST:             try:                recv_data = client.recv(BUFSIZ)            except Exception as ret:                print('*****客户端怎么还不发送数据呢*******')            else:                if recv_data:                    server_socket(tcpCliSock, recv_data)                # 如果客户端发送的数据为空，意味着客户端断开连接                # 先将客户端socket关闭                # 再将list中的客户端socket删除                else:                    client.close()                    SOCK_LIST.remove(client)        tcpSock.close()if __name__ == \"__main__\":    main()\n\n\n问题1：在打开html文件的时候，一直提示No such file or directory。检查发现html文件相对路径与代码相比没有问题，但是由于是在vscode终端运行，终端提示符的位置是在代码的上层目录，所以相对路径就不能以代码为准，而要以终端运行的位置为准。\n\n","plink":"http://localhost:4000/post/Http协议/"},{"title":"about","date":"2019-08-03T01:04:49.000Z","updated":"2019-08-03T01:06:53.619Z","content":"","plink":"http://localhost:4000/about/"}]